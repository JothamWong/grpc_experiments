import argparse

if __name__ == "__main__":
    argparser = argparse.ArgumentParser("Generate grpc server")
    argparser.add_argument("-n", "--n_messages", type=int, help="Num message types")
    argparser.add_argument("-nt", "--num_iterations", type=int, help="Num benchmark iterations")
    args = argparser.parse_args()
    n_messages = args.n_messages
    n_iterations = args.num_iterations
    initial = '''// This program is autogenerated. Do not modify.
#include "Statistics.hpp"
#include <ctime>
#include <functional>
#include <myproto/message.grpc.pb.h>

#include <grpc/grpc.h>
#include <grpcpp/create_channel.h>

#include <chrono>
#include <cmath>
#include <iostream>
#include <string>

using std::chrono::duration;
using std::chrono::duration_cast;
using std::chrono::high_resolution_clock;
using std::chrono::milliseconds;

#define NUM_ITERATIONS {N_ITERATIONS}

template <typename RequestType, typename ResponseType>
void benchmark_grpc_call(
    const std::string &name,
    std::function<grpc::Status(grpc::ClientContext *, const RequestType &,
                               ResponseType *)>
        grpc_call,
    std::function<void(RequestType &)> setup_request,
    std::unique_ptr<protobenchmark::Messages::Stub> &stub, int num_iterations) {
  std::cout << "Benchmarking " << name << std::endl;
  common::Statistics stats;

  for (int i = 0; i < num_iterations; i++) {
    std::cout << "Iteration " << i << std::endl;
    grpc::ClientContext context;
    RequestType request;
    ResponseType response;
    setup_request(request);
    auto t1 = high_resolution_clock::now();
    grpc::Status status = grpc_call(&context, request, &response);
    auto t2 = high_resolution_clock::now();

    double duration =
        std::chrono::duration<double, std::milli>(t2 - t1).count();
    stats.addMeasurement(duration);
    if (!status.ok()) {
      std::cerr << "Failed gRPC call for " << name << std::endl;
    }
  }
  stats.printResults(name);
  stats.writeToCSV(name);
}

int main(int argc, char *argv[]) {
  std::cout << "Client starting!" << std::endl;
  auto channel = grpc::CreateChannel("localhost:50051",
                                     grpc::InsecureChannelCredentials());
  std::unique_ptr<protobenchmark::Messages::Stub> stub =
      protobenchmark::Messages::NewStub(channel);
  std::cout << "Num iterations: " << NUM_ITERATIONS << std::endl;
  
  benchmark_grpc_call<google::protobuf::Empty, google::protobuf::Empty>(
      "Zero Arg Benchmark",
      [&stub](grpc::ClientContext *context,
              const google::protobuf::Empty &request,
              google::protobuf::Empty *response) {
        return stub->GetM0(context, request, response);
      },
      [](google::protobuf::Empty &request) {}, stub, NUM_ITERATIONS);   
    '''
    initial = initial.replace("{N_ITERATIONS}", str(n_iterations))
    program = [initial]
    
    for m in range(1, n_messages+1):
        program.append(f'  benchmark_grpc_call<protobenchmark::M{m}, protobenchmark::M{m}>("{m} Arg Benchmark",[&stub](grpc::ClientContext *context, const protobenchmark::M{m} &request, protobenchmark::M{m} *response) {{')
        program.append(f"       return stub->GetM{m}(context, request, response); }}, [](protobenchmark::M{m} &request) {{")
        for n in range(1, m):
            program.append(f"request.set_arg{n}(0);")
        program.append("}, stub, NUM_ITERATIONS);")
    program.append("    return 0; }")
    program_string = "\n".join(program)
    with open("src/main.cpp", "w") as outf:
        outf.write(program_string)